package pl.com.bms.fileSynchronizer.watch

import java.nio.file.StandardWatchEventKinds._
import java.nio.file._

import pl.com.bms.fileSynchronizer.HandlerFactory
import pl.com.bms.fileSynchronizer.fileUploader.{FileUploader, UploadResult}

import scala.collection.JavaConversions._

case class PathEvent(key: WatchKey, event: WatchEvent[_]) {
  def path = {
    val relativePath = event.context().asInstanceOf[Path]
    key.watchable().asInstanceOf[Path].resolve(relativePath)
  }

  /*
  This check prevents all temporary files
  generated by IntelliJ and vim from uploading
  Otherwise they generate java.io.IOException: {file} is not a regular file or directory
   */
  def appliesToRegularFile = path.toFile.isFile || path.toFile.isDirectory

  def kind = event.kind
}

class FileWatcher(val fileUploader: FileUploader, val sourceRoot: String) {

  val watchedFiles = collection.mutable.Map[String, () => UploadResult]()
  val handlerFactory = new HandlerFactory(fileUploader)
  val watcher: WatchService = FileSystems.getDefault.newWatchService()

  def isNotWatched(file: Path) = !(watchedFiles contains file.toString)
  
  def addToWatched(path: Path): Unit = {
    if(path.toFile.isDirectory)
      path.register(watcher, ENTRY_MODIFY, ENTRY_CREATE)
    else {
      val relativePath = Paths.get(sourceRoot).relativize(path).toString
      val handler = handlerFactory.getHandlerFor(relativePath)
      watchedFiles += (path.toString -> handler)
    }
  }

  def startWatching() = {
    while(true) {
      val key = watcher.take()
      goSleepToAvoidEventDuplication()
      key.pollEvents()
        .map(PathEvent(key, _))
        .filter(_.appliesToRegularFile)
        .foreach {
          event =>
            event.kind match {
              case ENTRY_MODIFY =>
                notifyHandlerAssignedTo(event.path)
              case ENTRY_CREATE =>
                if(isNotWatched(event.path)) {
                  addToWatched(event.path)
                  notifyHandlerAssignedTo(event.path)
                }
              case x =>
                println(s"Unexpected event $x")
            }
        }
      key.reset()
    }
  }

  /*
  More info: http://stackoverflow.com/questions/16777869/java-7-watchservice-ignoring-multiple-occurrences-of-the-same-event
   */
  private def goSleepToAvoidEventDuplication() = Thread.sleep(100)

  def notifyHandlerAssignedTo(path: Path) = {
    watchedFiles.get(path.toString) foreach {
      handler => handler()
    }
  }
  
}
